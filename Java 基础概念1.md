# 基础概念和常识

**1. Java语言的特点**：
答：简单易学、面向对象（封装继承多态）、平台无关性/可移植性强(JVM解释字节码进行运行)、支持多线程、可靠性（有异常处理机制和自动内存管理机制）、安全性（限制内存访问：访问权限修饰符）、高效性（JIT优化，边运行边编译）、方便网络编程、解释与编译并存（编辑过程生成字节码、JVM解释字节码）、生态好（开源贡献多）；
**2. Java SE/EE/ME**:
答：
JavaSE是Java标准版本，是后续Java版本的基础。包含支持Java程序开发和运行的核心类库和JVM等组件，可以用来开发桌面应用程序和简单的服务器应用程序。
JavaEE是Java公司版本，基于JavaSE的基础上包含支持大型Java程序开发、运行和部署的组件（Servlet、JSP、EJB、JDBC、JPA、JTA、Javamail、JMS），可以用于分布式、可移植、健壮、安全、可伸缩的服务端Java应用程序。
JavaME是Java的迷你版本，用于开发嵌入式或者手机等移动端应用，使用较少。
**3. JVM/JRE/JDK之间的关系:**
简答：JDK包含JRE，JRE包含JVM
详细答案：

**JDK:**

- 首先是JDK，JDK是全名是Java Development Kit，是一种功能齐全的Java开发工具包，用于Java项目的创建和编译。主要包含JRE（Java运行环境）、Javac（Java编译器）、以及其他的工具包：Javap（Java反编译工具）/Javadoc（Java文档生成器）/jconsole（Java监控工具）/jdb（调试器）
- 然后是JDK有开源OpenJDK和不开源OracleJDK两种版本,开源版本包含ailibaba的Dragonwell、亚麻的Amazon Corretto
- 在JDK9之后JDK采用了一种新的架构：模块系统+jlink工具来编译运行Java程序。当Java程序运行时，jlink将会创建一个自定义的Java runtime映像（运行时映像），映像中仅仅包含程序运行时必要的模块。
	 *优势： jlink根据需要创建自定义的更轻量的 runtime映像，不再是任何程序统一使用JRE进行运行，大大简化了应用的部署难度，节省了内存，并且提高了应用的安全性和可维护性。这种特性非常适合现代应用程序开发的需求，很好的契合云原生、分布式、虚拟化容器化的开发，非常重要*

**JRE:**

- JRE全名是Java Runtime, 是运行已经编译的Java程序所需要的环境。JRE主要包含两个组件：

- *JVM：Java虚拟机*

- *Java基础类库（Class Library）:一组标准的类库，包含常用的功能和API（I/O操作、网络通信、数据结构等）*

简单来说就是JRE仅仅只是包含运行Java程序所需要的环境和类库，而JDK不仅仅包含JRE，也包含开发和调试Java程序所需要的工具。

**JVM：**

- JVM全名是Java虚拟机，是一种专门运行Java字节码的虚拟机，针对不同系统上有特定的实现，目的是结合字节码，通过解释字节码来在不同的系统上得到相同的结果

- JVM结合Java编译后的字节码是Java程序“一次编译，随处运行”的核心

- JVM不只有一种，只要符合JVM规范都可以可以叫做JVM，常见的有HotSpot VM 、 J9 VM、Zing VM、JRockit VM 等 JVM

# Java语法
**注释有哪几种形式？**
答：Java程序的注释主要有三种：
- 单行注释：用于解释方法内单行代码的作用
- 多行注释：解释一段代码的作用
- 文档注释：用于Java开发文档
注释用于团队协作开发之间帮助其他人看懂你的代码，帮助其他人快速理清代码之间的逻辑关系，实际上有的时候好的代码本身就是注释，在清楚地写明注释的时候也要尽量写出优美的代码

**标识符vs关键字之间的区别是什么？**

- 标识符就是平时给变量函数命名的时候取的名字
- 有的时候一些特定单词在Java程序中有特殊含义，比如const，private、class这些，这些特殊含义的标识符就是关键字
- 切记：关键字不能被当作一般标识符使用

**常用关键字梳理**

- 访问控制：private，public，protected

- 程序流程控制：break，continue，return，while，for，if，else等

- 异常处理：try，catch，throws，throw，finally

- 依赖包导入：import，package

- 变量类型：略

- 变量引用：void，super，this

- 保留字：const，goto
注意：**true、false，Null**是字面值，不是关键字

**自增自减运算符**略

**介绍一下移位运算符(左移右移)**：
答：
使用移位运算符的主要原因有以下两个：
- 高效：位移运算符直接对应处理器中的位移指令，现代处理器具有专门的硬件指令来执行这些移位操作，这些指令通常在一个时钟周期内完成。相比之下，乘法和除法等算术运算在硬件层面上需要更多的时钟周期来完成。
- 节约内存：通过移位操作，可以让一个整数来储存多个布尔值或者标志位，从而达到节约内存的目的
- 更常见的是快速执行2的幂次方的乘法和除法运算

------
使用场景:
- 位字段管理：一个整数储存和操作多个布尔值
- 哈希算法和加密解密：通过移位和与、或等混淆数据
- 数据压缩：
- 数据校验：
- 内存对齐：通过移位操作，计算调整数据的对齐地址

------
*如果移位的位数大于数字的二进制位数应该怎么办？*
答：这里先明确一下数字的类型，int类型占位32位，如果进行超过32位的位移，那么移位的位数先对32取mod，再使用取mod的结果进行移位；如果是long 类型，也就是64位，那么就是对64取mod

**简要讲一下return，continue，break的区别**
答：首先是continue和break，用在循环中对流程进行控制；continue是跳过当前循环，执行下一次循环，break是跳出整个循环体，执行循环下面的语句；
return是用于结束一个函数或者是一个方法，如果函数不需要返回任何值，直接return；如果需要往其他地方返回一个值，则return value；

# Java基本数据类型
**简单介绍一下Java几种基本的常用数据类型？**
答：

- 数字：

  - 整数：byte，short，int，long

  - 浮点数：float，double

- 字符：char

- 布尔值：boolean

整数表示位数都是最大位数-1，原因是符号位占位，如果此时加1会导致整型溢出，使得正数变为负数。

对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。

另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一

*注意：
代码在编写时注意以下几个点：
1.Java里面long前面要加上L，否则无法作为整型解析
2.float前面要加上f或者F，否则编译报错
3.字符char单引号字符串双引号
4.八种基本类型对应包装类：Byte，Short，Integer，Long，Float，Double，Character，Boolean*

**基本类型和包装类型的区别**
答：
- 使用场景不同：除了定义局部变量或者常量的时候我们使用基本类型进行定义，在其他场景比如定义对象属性或者定义方法参数的时候都是使用包装类型进行定义。另外包装类型可以用于泛型，但是基本类型不可以
- 占用空间：包装类型占用空间比较多，基本类型占用空间比较小
- 默认值：包装类型默认值是null，而基本类型有默认值，但不是null：局部变量可以是任意值，类变量是0，bool的话是False
- 比较方式：包装类型如果是整型，那么用equal()来进行比较；如果是浮点数，用Compare进行比较；包装类型如果用“==”进行比较，比较的是地址，涉及到后面包装变量的缓存机制，有的时候地址相同有的时候地址不同，取决于值的范围；基本类型比较值使用“==”直接进行比较
- 变量存储方式不同:
	- 包装类型：包装类型属于对象类型，基本上所有的对象类型都是存储在堆上（涉及到逃逸分析）
	- 基本类型：如果是定义在类中,作为成员变量,没有用static修饰，分配堆上内存；如果用Static修饰了，在JDK1.7之前放在方法区，JDK1.8以后放在元空间；如果是定义为局部变量，分配栈上内存；

**为什么说几乎所有对象类型都会被存放在堆中？**
答：这里涉及到JIT的逃逸分析；JIT通过分析程序中的对象，将某些只在一个方法中临时使用，并不在其他地方被使用的对象放在栈上（没有逃逸到方法外部）；将在外部使用的方法分配到堆上；这样大大节省了内存，提高了程序的效率；
参考：[JIT逃逸分析原理](https://blog.csdn.net/m0_60641871/article/details/132220841)

**包装类型的缓存机制了解吗？简要介绍一下？**
答：
- Java中基本数据类型的包装类型有一些采用了缓存机制来提升程序的性能。Byte，Integer，Short，Long默认创建数值范围为【-128，127】的对应类型的缓存数据。Character默认创建数据范围为【0，127】范围的对应类型的缓存数据。Boolean直接返回True/False

- 在这些范围内声明对象，对象直接在VarCache.cache()中产生，也就是复用已有对象，地址相同值相同；超出范围则在堆上创建新的对象，地址不同；这种特性导致所有整型对象都得用equal()方法来判断。

- 包装类Float和Double没有实现缓存机制

- 【重点:】看一下每个包装类的缓存源码！！！！！
[Intenger缓存机制](https://www.cnblogs.com/rouqinglangzi/p/8848607.html#_lab2_2_0)
```Java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false

Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);//输出False，因为new了一个新的对象
```

**自动装箱和拆箱？简单介绍一下？**

答：

- 装箱：将基本数据类型用它们对应的引用类包装起来，在字节码中本质上是调用valueOf()方法

- 拆箱：将包装类型转换成对应的基本类型，在字节码中本质上是调用xxxValue()方法

*频繁装箱拆箱会严重影响程序运行的效率*

**为什么浮点数计算的时候会有精度损失的风险？**
答：
计算机表示数字的宽度是有限的，当浮点数的长度超过了数字的宽度的时候，计算机就会截断超出的部分，从而导致精度的损失；也是因为这个原因，浮点数无法被二进制表示

**浮点数精度损失如何解决？**
答：
目前主流的方法是使用BigDecimal来表示浮点数，不会发生精度的损失。目前大部分的需要浮点数精确运算的场景（涉及到钱的场景），都使用BigDecimal来进行运算；

**超过long的整形如何表示？**
答：
超过Long的整数使用BigInteger来进行表示，BigInteger通过int[]数组来表示数字的每一位，所以可以储存任意大小的整形数据；

# 变量
**讲一下成员变量和局部变量的区别？**
答：区别主要有以下几个要点：
- 语法差异：从语法形式上来看，成员变量是属于类的，局部变量是在代码块或者是方法中定义的变量或者是方法的参数；成员变量可以被访问控制符和static修饰，局部变量无法被访问控制符修饰，也不能够被static修饰；成员变量和局部变量都可以被final修饰；
- 存储模式：从变量在内存中的存储模式上来看，成员变量未被static修饰的时候是属于实例的，存储在堆上，被static修饰过后是属于类的，存储在元空间或者是方法区；局部变量存储在栈内存上；
- 生命周期：成员变量是对象的一部分，对象创建成员变量就被创建，随着对象的消失而消失；局部变量随着方法的调用开始而存在，方法调用结束消亡。
- 默认值：成员变量如果没有被final修饰，自动赋值默认值；被final修饰的成员变量需要显式赋值；局部变量创建时不会被赋予默认值，会被赋予随机一个值；

**为什么成员变量有默认值？**
答：
- 假设变量没有默认值，那么变量读取的就是地址上存储的随机值，从而导致程序出现不可预测的风险和意外；
- 首先是默认值有两种设置方式：手动赋值和自动赋值。结合上面，变量没有手动赋值的话一定要自动赋值，成员变量可以通过反射等方式手动赋值，但是局部变量不行
- 对于javac编译器来说，局部变量没有赋值很好判断，可以直接报错；但是成员变量有的时候是在运行时赋值，如果直接通过编译器来报错的话很容易产生误报，所以直接自动赋默认值；

**静态变量有什么作用？**
答：静态变量就是用static修饰的成员变量，可以被所有同一个类创建的实例共享。静态变量只会被分配一次内存，同一个类的所有实例都共享同一个静态变量，因此可以节约内存。
静态变量通过类名.变量名来进行访问。一般成员变量通过实例名.变量名来进行访问。

*1.静态变量通过class类名来进行访问，这种特性区分了一般成员变量和静态变量的差别*

**字符型常量和字符串型常量的区别**
答：

- 形式不同：字符型常量用单引号定义，字符串型常量用双引号定义
- 占用内存不同：字符型常量是char类型，占两个字节；字符串型常量占用若干个字节
- 含义不同：字符型常量本质上存储的是一个ASCALL码，可以参加表达式运算；字符串型常量存储的是一个内存的地址，该地址存放定义好的字符串

# 方法

**什么是方法的返回值？方法有哪几种类型？**

答：方法的返回值是方法在执行结束后得到的一个结果，有可能有也有可能没有；返回值的作用是输出方法中流程结束产生的结果，使它可以用于其他地方的操作。

方法的几种类型：1.有参数有返回值 2.有参数无返回值 3.无参数有返回值 4.无参数无返回值

**静态方法为什么不能调用非静态成员？**

答：JVM的原因。

- 类中的静态方法是属于类的，在类加载的时候就已经会分配内存，可以通过类名直接访问；但是非静态变量是属于实例的，只有在对象实例化的时候才会被分配内存，只能通过实例对象来访问；

- 所以用一个已经分配内存的方法去访问一个还没有被分配内存的变量，这显然是不可能的

**静态方法和实例方法有什么不同？**
答：
- 分配内存的先后时间不一样：静态方法是属于类的，在创建类的时候就会对其分配内存；实例方法是属于实例的，只有在创建实例的时候才会分配内存；
- 调用方式不一样：静态方法通过类名.方法名或者实例名.方法名进行调用，但是建议还是用类名.方法名进行调用，避免混淆；实例方法通过实例名.方法名进行调用；
- 访问类成员限制不一样：实例方法访问类成员的时候没有任何限制；静态方法只能访问类的静态成员（还是JVM的问题）；

**简要介绍一下重载和重写之间的区别？**
答：
- 重载：同名方法，传参不同，执行方式不同
- 重写：override，继承父类方法，对父类方法进行改写；(两同两小一大)

**什么是可变长参数？**
答：
从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。

遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。

编译后的字节码中可变长数组实际上被转化成了一个数组