# 基础概念和常识

**1. Java语言的特点**：
答：简单易学、面向对象（封装继承多态）、平台无关性/可移植性强(JVM解释字节码进行运行)、支持多线程、可靠性（有异常处理机制和自动内存管理机制）、安全性（限制内存访问：访问权限修饰符）、高效性（JIT优化，边运行边编译）、方便网络编程、解释与编译并存（编辑过程生成字节码、JVM解释字节码）、生态好（开源贡献多）；
**2. Java SE/EE/ME**:
答：
JavaSE是Java标准版本，是后续Java版本的基础。包含支持Java程序开发和运行的核心类库和JVM等组件，可以用来开发桌面应用程序和简单的服务器应用程序。
JavaEE是Java公司版本，基于JavaSE的基础上包含支持大型Java程序开发、运行和部署的组件（Servlet、JSP、EJB、JDBC、JPA、JTA、Javamail、JMS），可以用于分布式、可移植、健壮、安全、可伸缩的服务端Java应用程序。
JavaME是Java的迷你版本，用于开发嵌入式或者手机等移动端应用，使用较少。
**3. JVM/JRE/JDK之间的关系:**
简答：JDK包含JRE，JRE包含JVM
详细答案：

**JDK:**

- 首先是JDK，JDK是全名是Java Development Kit，是一种功能齐全的Java开发工具包，用于Java项目的创建和编译。主要包含JRE（Java运行环境）、Javac（Java编译器）、以及其他的工具包：Javap（Java反编译工具）/Javadoc（Java文档生成器）/jconsole（Java监控工具）/jdb（调试器）
- 然后是JDK有开源OpenJDK和不开源OracleJDK两种版本,开源版本包含ailibaba的Dragonwell、亚麻的Amazon Corretto
- 在JDK9之后JDK采用了一种新的架构：模块系统+jlink工具来编译运行Java程序。当Java程序运行时，jlink将会创建一个自定义的Java runtime映像（运行时映像），映像中仅仅包含程序运行时必要的模块。
	 *优势： jlink根据需要创建自定义的更轻量的 runtime映像，不再是任何程序统一使用JRE进行运行，大大简化了应用的部署难度，节省了内存，并且提高了应用的安全性和可维护性。这种特性非常适合现代应用程序开发的需求，很好的契合云原生、分布式、虚拟化容器化的开发，非常重要*

**JRE:**

- JRE全名是Java Runtime, 是运行已经编译的Java程序所需要的环境。JRE主要包含两个组件：

- *JVM：Java虚拟机*

- *Java基础类库（Class Library）:一组标准的类库，包含常用的功能和API（I/O操作、网络通信、数据结构等）*

简单来说就是JRE仅仅只是包含运行Java程序所需要的环境和类库，而JDK不仅仅包含JRE，也包含开发和调试Java程序所需要的工具。

**JVM：**

- JVM全名是Java虚拟机，是一种专门运行Java字节码的虚拟机，针对不同系统上有特定的实现，目的是结合字节码，通过解释字节码来在不同的系统上得到相同的结果

- JVM结合Java编译后的字节码是Java程序“一次编译，随处运行”的核心

- JVM不只有一种，只要符合JVM规范都可以可以叫做JVM，常见的有HotSpot VM 、 J9 VM、Zing VM、JRockit VM 等 JVM

# Java语法
**注释有哪几种形式？**
答：Java程序的注释主要有三种：
- 单行注释：用于解释方法内单行代码的作用
- 多行注释：解释一段代码的作用
- 文档注释：用于Java开发文档
注释用于团队协作开发之间帮助其他人看懂你的代码，帮助其他人快速理清代码之间的逻辑关系，实际上有的时候好的代码本身就是注释，在清楚地写明注释的时候也要尽量写出优美的代码

**标识符vs关键字之间的区别是什么？**

- 标识符就是平时给变量函数命名的时候取的名字
- 有的时候一些特定单词在Java程序中有特殊含义，比如const，private、class这些，这些特殊含义的标识符就是关键字
- 切记：关键字不能被当作一般标识符使用

**常用关键字梳理**

- 访问控制：private，public，protected

- 程序流程控制：break，continue，return，while，for，if，else等

- 异常处理：try，catch，throws，throw，finally

- 依赖包导入：import，package

- 变量类型：略

- 变量引用：void，super，this

- 保留字：const，goto
注意：**true、false，Null**是字面值，不是关键字

**自增自减运算符**略

**介绍一下移位运算符(左移右移)**：
答：
使用移位运算符的主要原因有以下两个：
- 高效：位移运算符直接对应处理器中的位移指令，现代处理器具有专门的硬件指令来执行这些移位操作，这些指令通常在一个时钟周期内完成。相比之下，乘法和除法等算术运算在硬件层面上需要更多的时钟周期来完成。
- 节约内存：通过移位操作，可以让一个整数来储存多个布尔值或者标志位，从而达到节约内存的目的
- 更常见的是快速执行2的幂次方的乘法和除法运算

------
使用场景:
- 位字段管理：一个整数储存和操作多个布尔值
- 哈希算法和加密解密：通过移位和与、或等混淆数据
- 数据压缩：
- 数据校验：
- 内存对齐：通过移位操作，计算调整数据的对齐地址

------
*如果移位的位数大于数字的二进制位数应该怎么办？*
答：这里先明确一下数字的类型，int类型占位32位，如果进行超过32位的位移，那么移位的位数先对32取mod，再使用取mod的结果进行移位；如果是long 类型，也就是64位，那么就是对64取mod

**简要讲一下return，continue，break的区别**
答：首先是continue和break，用在循环中对流程进行控制；continue是跳过当前循环，执行下一次循环，break是跳出整个循环体，执行循环下面的语句；
return是用于结束一个函数或者是一个方法，如果函数不需要返回任何值，直接return；如果需要往其他地方返回一个值，则return value；

# Java基本数据类型
**简单介绍一下Java几种基本的常用数据类型？**
答：

- 数字：

  - 整数：byte，short，int，long

  - 浮点数：float，double

- 字符：char

- 布尔值：boolean

整数表示位数都是最大位数-1，原因是符号位占位，如果此时加1会导致整型溢出，使得正数变为负数。

对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。

另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一

*注意：
代码在编写时注意以下几个点：
1.Java里面long前面要加上L，否则无法作为整型解析
2.float前面要加上f或者F，否则编译报错
3.字符char单引号字符串双引号
4.八种基本类型对应包装类：Byte，Short，Integer，Long，Float，Double，Character，Boolean*

**基本类型和包装类型的区别**
答：
- 使用场景不同：除了定义局部变量或者常量的时候我们使用基本类型进行定义，在其他场景比如定义对象属性或者定义方法参数的时候都是使用包装类型进行定义。另外包装类型可以用于泛型，但是基本类型不可以
- 占用空间：包装类型占用空间比较多，基本类型占用空间比较小
- 默认值：包装类型默认值是null，而基本类型有默认值，但不是null：局部变量可以是任意值，类变量是0，bool的话是False
- 比较方式：包装类型如果是整型，那么用equal()来进行比较；如果是浮点数，用Compare进行比较；包装类型如果用“==”进行比较，比较的是地址，涉及到后面包装变量的缓存机制，有的时候地址相同有的时候地址不同，取决于值的范围；基本类型比较值使用“==”直接进行比较
- 变量存储方式不同:
	- 包装类型：包装类型属于对象类型，基本上所有的对象类型都是存储在堆上（涉及到逃逸分析）
	- 基本类型：如果是定义在类中,作为成员变量,没有用static修饰，分配堆上内存；如果用Static修饰了，在JDK1.7之前放在方法区，JDK1.8以后放在元空间；如果是定义为局部变量，分配栈上内存；

**为什么说几乎所有对象类型都会被存放在堆中？**
答：这里涉及到JIT的逃逸分析；JIT通过分析程序中的对象，将某些只在一个方法中临时使用，并不在其他地方被使用的对象放在栈上（没有逃逸到方法外部）；将在外部使用的方法分配到堆上；这样大大节省了内存，提高了程序的效率；
参考：[JIT逃逸分析原理](https://blog.csdn.net/m0_60641871/article/details/132220841)

**包装类型的缓存机制了解吗？简要介绍一下？**
答：
- Java中基本数据类型的包装类型有一些采用了缓存机制来提升程序的性能。Byte，Integer，Short，Long默认创建数值范围为【-128，127】的对应类型的缓存数据。Character默认创建数据范围为【0，127】范围的对应类型的缓存数据。Boolean直接返回True/False

- 在这些范围内声明对象，对象直接在VarCache.cache()中产生，也就是复用已有对象，地址相同值相同；超出范围则在堆上创建新的对象，地址不同；这种特性导致所有整型对象都得用equal()方法来判断。

- 包装类Float和Double没有实现缓存机制

- 【重点:】看一下每个包装类的缓存源码！！！！！
[Intenger缓存机制](https://www.cnblogs.com/rouqinglangzi/p/8848607.html#_lab2_2_0)
```Java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false

Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);//输出False，因为new了一个新的对象
```

**自动装箱和拆箱？简单介绍一下？**

答：

- 装箱：将基本数据类型用它们对应的引用类包装起来，在字节码中本质上是调用valueOf()方法

- 拆箱：将包装类型转换成对应的基本类型，在字节码中本质上是调用xxxValue()方法

*频繁装箱拆箱会严重影响程序运行的效率*

**为什么浮点数计算的时候会有精度损失的风险？**
答：
计算机表示数字的宽度是有限的，当浮点数的长度超过了数字的宽度的时候，计算机就会截断超出的部分，从而导致精度的损失；也是因为这个原因，浮点数无法被二进制表示

**浮点数精度损失如何解决？**
答：
目前主流的方法是使用BigDecimal来表示浮点数，不会发生精度的损失。目前大部分的需要浮点数精确运算的场景（涉及到钱的场景），都使用BigDecimal来进行运算；

**超过long的整形如何表示？**
答：
超过Long的整数使用BigInteger来进行表示，BigInteger通过int[]数组来表示数字的每一位，所以可以储存任意大小的整形数据；

# 变量
*临时记录:
1.静态变量通过class类名来进行访问，这种特性区分了一般成员变量和静态变量的差别
2.静态方法*




# 方法

*临时记录：
1.静态方法
2.重载：同一个类中多个同名方法，但是参数不同
3.可变长参数的重载
4.*

